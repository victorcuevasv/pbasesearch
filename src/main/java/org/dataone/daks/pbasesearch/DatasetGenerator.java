package org.dataone.daks.pbasesearch;

import java.io.*;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.List;
import java.util.Random;

import org.antlr.runtime.*;
import org.antlr.runtime.tree.*;
import org.dataone.daks.pbase.treecover.Digraph;
import org.dataone.daks.seriespar.*;
import org.json.*;


public class DatasetGenerator {

	
	//Minimum number of traces to generate for a given workflow
	private static final int MINTRACES = 1;
	//Maximum number of traces to generate for a given workflow
	private static final int MAXTRACES = 2;
	private Random rand;
	private APISCatalog catalog;
	
	
	public DatasetGenerator(String apisFolder, String genericApisFile, String specificApisFile) {
		this.rand = new Random();
		this.catalog = new APISCatalog(apisFolder, genericApisFile, specificApisFile);
	}  
	
	
	public static void main(String args[]) {
		if( args.length != 5 ) {
			System.out.println("Usage: java org.dataone.daks.pbasesearch.DatasetGenerator <wf names file> <wfs folder prefix> "     
					+ "<apis folder> <generic apis file> <specific apis file");     
			System.exit(0);
		}
		DatasetGenerator generator = new DatasetGenerator(args[2], args[3], args[4]);
		generator.generateDataset(args[0], args[1], "numtraces.txt");
	}
	
	
	public void generateDataset(String wfNamesFile, String wfsFolderPrefix, String numTracesFile) {
		//Create a list with the workflow names
		List<String> wfNames = readFileAsList(wfNamesFile);
		//Generate workflows and traces
		Hashtable<String, Integer> numTracesHT = new Hashtable<String, Integer>();
		for( String wfName: wfNames ) {
			int nTraces = this.generateWfAndTraces(wfName, wfsFolderPrefix);
			numTracesHT.put(wfName, nTraces);
		}
		this.saveNumTracesFile(numTracesHT, numTracesFile);
	}
	
	
	public int generateWfAndTraces(String wfName, String wfsFolderPrefix) {
		//Generate the ASM
		SeriesParallelGenerator spGenerator = new SeriesParallelGenerator();
		int minStatements = 2;
		int maxStatements = 4;
		double nonTermProb = 0.6;
		double weaken = 0.1;
		String asmText = spGenerator.asm(minStatements, maxStatements, nonTermProb, weaken);
		this.saveTextToFile(asmText, wfsFolderPrefix + "/" + wfName + ".txt");
		int nTraces = 0;
        try {
        	//Create a CharStream that reads from the input stream provided as a parameter
        	ANTLRStringStream input = new ANTLRStringStream(asmText);
        	//Create a lexer that feeds-off of the input CharStream
        	ASMSimpleLexer lexer = new ASMSimpleLexer(input);
        	//Create a buffer of tokens pulled from the lexer
        	CommonTokenStream tokens = new CommonTokenStream(lexer);
        	//Create a parser that feeds off the tokens buffer
        	ASMSimpleParser parser = new ASMSimpleParser(tokens);
        	//Begin parsing at rule query
        	ASMSimpleParser.asm_return result = null;
    		result = parser.asm();
        	//Pull out the tree and cast it
        	Tree t = (Tree)result.getTree();    	
            //System.out.println(t.toStringTree());
            //Execute the walker over the AST generated by the parser
            CommonTreeNodeStream nodes = new CommonTreeNodeStream(t);
            nodes.setTokenStream(tokens);
            ASMSimpleGraph walker = new ASMSimpleGraph(nodes);
            //Execute the walker beginning at the query rule
            walker.asm();
			ASTtoDigraph astToDigraph = walker.astToDigraph;
			Digraph wfGraph = astToDigraph.getDigraph();
			//System.out.println(graph.toString());
			//Generate the workflow graph files
			wfGraph.toDotFile(wfsFolderPrefix + "/" + wfName + ".dot", false);
			ASMApisSimulator simulator = new ASMApisSimulator();
			simulator.init(asmText);
			Hashtable<String, String> bindings = new Hashtable<String, String>();
			JSONObject wfGraphObj = this.generateWFJSON(wfGraph, bindings);
			this.saveJSONObjAsFile(wfGraphObj, wfsFolderPrefix + "/" + wfName + ".json");
			//Generate the traces
			nTraces = randInt(MINTRACES, MAXTRACES);
			for(int i = 1; i <= nTraces; i++) {
				//Run the simulator with the ASM tree
				simulator.run();
				simulator.getTraceDigraph().toDotFile(wfsFolderPrefix + "/" + wfName + "trace" + i + ".dot", true);     
				JSONObject traceGraphObj = this.generateTraceJSON(simulator.getTraceDigraph(), bindings);
				this.saveJSONObjAsFile(traceGraphObj, wfsFolderPrefix + "/" + wfName + "trace" + i + ".json");
			}
		}
        catch (RecognitionException e) {
			e.printStackTrace();
		}
        return nTraces;
	}
	
	
	private JSONObject generateWFJSON(Digraph graph, Hashtable<String, String> bindings) {
		List<String> nodes = graph.getVertices();
		JSONArray nodesArray = new JSONArray();
		JSONArray edgesArray = new JSONArray();
		JSONObject graphObj = new JSONObject();
		String specificAPIName = this.catalog.getRandomSpecificAPIName();
		try {
			for(String node1Id: nodes) {
				JSONObject nodeObj = new JSONObject();
				nodeObj.put("nodeId", node1Id);
				String service = this.catalog.getRandomService(specificAPIName);
				nodeObj.put("service", service);
				bindings.put(node1Id, service);
				nodesArray.put(nodeObj);
				List<String> adjList = graph.getAdjList(node1Id);
				for( String node2Id: adjList ) {
					JSONObject edgeObj = new JSONObject();
					edgeObj.put("startNodeId", node1Id);
					edgeObj.put("edgeLabel", "");
					edgeObj.put("endNodeId", node2Id);
					edgesArray.put(edgeObj);
				}
			}
			graphObj.put("nodes", nodesArray);
			graphObj.put("edges", edgesArray);
		}
		catch (JSONException e) {
			e.printStackTrace();
		}
		return graphObj;
	}
	
	
	private JSONObject generateTraceJSON(Digraph graph, Hashtable<String, String> bindings) {
		List<String> nodes = graph.getVertices();
		JSONArray nodesArray = new JSONArray();
		JSONArray edgesArray = new JSONArray();
		JSONObject graphObj = new JSONObject();
		boolean node1IdisData = false;
		try {
			for(String node1Id: nodes) {
				if( node1Id.contains("_") )
					node1IdisData = true;
				JSONObject nodeObj = new JSONObject();
				nodeObj.put("nodeId", node1Id);
				nodesArray.put(nodeObj);
				if( ! node1IdisData ) {
					String service = bindings.get(node1Id);
					nodeObj.put("service", service);
				}
				List<String> adjList = graph.getAdjList(node1Id);
				for( String node2Id: adjList ) {
					JSONObject edgeObj = new JSONObject();
					edgeObj.put("startNodeId", node1Id);
					if( node1IdisData )
						edgeObj.put("edgeLabel", "wasGenBy");
					else
						edgeObj.put("edgeLabel", "used");
					edgeObj.put("endNodeId", node2Id);
					edgesArray.put(edgeObj);
				}
				node1IdisData = false;
			}
			graphObj.put("nodes", nodesArray);
			graphObj.put("edges", edgesArray);
		}
		catch (JSONException e) {
			e.printStackTrace();
		}
		return graphObj;
	}
	
	
	private void saveNumTracesFile(Hashtable<String, Integer> numTracesHT, String filename) {
		try {
			PrintWriter writer = new PrintWriter(new BufferedWriter(new FileWriter(filename)));
			Enumeration<String> e = numTracesHT.keys();
		    while(e.hasMoreElements()) {
		    	String wfId = e.nextElement();
		    	int nTraces = numTracesHT.get(wfId);
		    	writer.println(wfId + " " + nTraces + " ");
		    }
			writer.close();
		}
		catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	
	private List<String> readFileAsList(String filename) {
		BufferedReader reader = null;
		List<String> list = new ArrayList<String>();
		try {
			String line = null;
			reader = new BufferedReader(new FileReader(filename));
			while( (line = reader.readLine()) != null ) {
				if( line.trim().length() > 0 )
					list.add(line);
			}
			reader.close();
		}
		catch(IOException e) {
			e.printStackTrace();
		}
		return list;
	}
	
	
	private void saveTextToFile(String text, String filename) {
		try {
			PrintWriter writer = new PrintWriter(new BufferedWriter(new FileWriter(filename)));
			writer.print(text);
			writer.close();
		}
		catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	
	public void saveJSONObjAsFile(JSONObject jsonObj, String filename) {
		try {
			PrintWriter writer = new PrintWriter(new BufferedWriter(new FileWriter(filename)));
			String jsonStr = jsonObj.toString();
			writer.print(jsonStr);
			writer.close();
		}
		catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	
    private int randInt(int min, int max) {
	    int randomNum = this.rand.nextInt((max - min) + 1) + min;
	    return randomNum;
	}
	
	
}




